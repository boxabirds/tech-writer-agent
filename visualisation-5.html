<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Code Analysis Visualization (Automated)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #111; color: #eee; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.75);
            padding: 15px;
            border-radius: 5px;
            max-width: 350px;
            font-size: 13px;
            line-height: 1.4;
            z-index: 20; /* Ensure info panel is above labels */
        }
        #info h2 { margin-top: 0; }
        #status-line { margin-top: 10px; font-weight: bold; }
        #legend { margin-top: 15px; border-top: 1px solid #555; padding-top: 10px; }
        #legend h3 { margin: 0 0 5px 0; font-size: 1em; }
        #legend ul { list-style: none; padding: 0; margin: 0; }
        #legend li { margin-bottom: 4px; display: flex; align-items: center; }
        .legend-color {
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border: 1px solid #888;
            display: inline-block;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 20; /* Ensure controls are above labels */
        }
        button {
            margin: 5px;
            padding: 8px 12px;
            cursor: pointer;
            background-color: #444;
            color: #eee;
            border: 1px solid #666;
            border-radius: 3px;
        }
        button:hover { background-color: #555; }
        button:disabled { background-color: #333; color: #888; cursor: not-allowed; }
        .tooltip {
            position: absolute;
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 11px;
            white-space: pre-wrap;
            pointer-events: none;
            display: none;
            max-width: 400px;
            border: 1px solid #777;
            z-index: 100; /* Tooltip above everything */
        }
        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks through to canvas */
            overflow: hidden;
            z-index: 10; /* Labels below info/controls but above canvas */
        }
        .object-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px; /* Keep small for sub-prompts */
            white-space: nowrap;
            transform: translateX(-50%); /* Center horizontally */
            user-select: none; /* Prevent text selection */
        }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="info">
        <h2>Code Analysis Flow (ReAct)</h2>
        <p>Visualizing the interaction between Prompts, LLM, and Tools, including memory accumulation.</p>
        <div id="status-line"><strong>Current Step:</strong> <span id="status">Idle</span></div>
        <p>Use mouse to rotate/zoom. Hover for details. Click button below to start.</p>
        <div id="legend">
            <h3>Legend</h3>
            <ul>
                <li><span class="legend-color" style="background-color: #0077cc;"></span>LLM Core</li>
                <li><span class="legend-color" style="background-color: #cc0000;"></span>System Prompt</li>
                <li><span class="legend-color" style="background-color: #ff6666;"></span>Sub-Prompt Component</li>
                <li><span class="legend-color" style="background-color: #00cc00;"></span>User Prompt</li>
                <li><span class="legend-color" style="background-color: #ffaa00;"></span>Tool</li>
                <li><span class="legend-color" style="background-color: #ffff00;"></span>Signal (Info Flow)</li>
                <li><span class="legend-color" style="background-color: #cc00cc;"></span>Final Answer</li>
                <li><span class="legend-color" style="background-color: #aaaaaa; height: 2px; border: none; width: 15px; vertical-align: middle;"></span>Connection</li>
                <li><span class="legend-color" style="background-color: #6c757d;"></span>Memory Block</li>
            </ul>
        </div>
    </div>
    <div id="controls">
        <button id="startButton">Start Analysis</button>
        <!-- Removed Next Step Button -->
        <button id="resetButton">Reset</button>
    </div>
    <div id="tooltip" class="tooltip">Tooltip</div>
    <div id="labels-container"></div>

    <!-- Libraries -->
    <script src="https://unpkg.com/matter-js@0.19.0/build/matter.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <!-- Main Application Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Configuration ---
        const Colors = {
            background: 0x111111,
            ambientLight: 0x404040,
            directionalLight: 0xffffff,
            llm: 0x0077cc, // Blue
            systemPrompt: 0xcc0000, // Red
            subPrompt: 0xff6666, // Lighter Red
            userPrompt: 0x00cc00, // Green
            tool: 0xffaa00, // Orange
            connection: 0xaaaaaa,
            signal: 0xffff00, // Yellow
            finalAnswer: 0xcc00cc, // Purple
            memory: 0x6c757d, // Grey for memory blocks
        };

        const Sizes = {
            llmRadius: 30,
            promptSize: 15,
            subPromptSize: 8,
            toolSize: 20,
            signalRadius: 3,
            labelOffset: 1.2, // Multiplier for label distance from object center (Y-axis)
            memoryBlockWidth: 5,
            memoryBlockHeight: 10,
            memoryBlockDepth: 2,
            memoryStackOffset: 5, // Vertical distance between memory blocks
            memoryStackXOffset: 45, // Horizontal offset from LLM center
        };

        // --- Data (Ensure this is complete) ---
        const PromptData = {
            ROLE_AND_TASK: "Expert tech writer role, analyze codebase task.",
            GENERAL_ANALYSIS_GUIDELINES: "Use tools, be accurate, structured, cite sources.",
            INPUT_PROCESSING_GUIDELINES: "Use base directory, handle errors, structured summaries.",
            CODE_ANALYSIS_STRATEGIES: "Explore structure, identify key files, ignore temp files, analyze relationships.",
            REACT_PLANNING_STRATEGY: "ReAct Pattern: Thought -> Action -> Observation -> Repeat.",
            QUALITY_REQUIREMENTS: "MECE analysis, thorough, accurate, helpful Markdown output.",
            USER_PROMPT_EXAMPLE: "Base directory: /path/to/codebase\n\nAnalyze the main application logic and dependencies."
        };

        const ToolData = {
            find_all_matching_files: "Finds files matching a pattern, respects .gitignore.",
            read_file: "Reads the content of a non-binary file.",
            calculate: "Evaluates a safe mathematical expression."
        };

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let engine, world;
        let objects = {
            llm: null,
            systemPrompt: null,
            subPrompts: [], // Stores { mesh, body, name }
            userPrompt: null,
            tools: {}, // Stores { name: { mesh, body, name } }
            connections: [], // Stores THREE.Line objects
            signals: [], // Stores { mesh, startTime, duration, startPos, endPos, onComplete }
            finalAnswerObj: null // Stores { mesh, startTime, labelElement? }
        };
        let matterBodies = []; // All Matter.js bodies managed
        let threeMeshes = []; // Corresponding Three.js meshes for raycasting/lookup
        let labeledObjects = []; // Stores { mesh, labelElement, text, size } for label positioning
        let constraints = []; // Stores Matter.js constraints
        let memoryItems = []; // Stores THREE.Mesh objects for memory blocks
        // Define simulation states
        const SIM_STATE = {
            IDLE: 'idle',
            PROMPTS_TO_LLM: 'prompts_to_llm',
            LLM_THINKING: 'llm_thinking', // Deciding which tool to call
            LLM_TO_TOOL: 'llm_to_tool',
            TOOL_PROCESSING: 'tool_processing',
            TOOL_TO_LLM: 'tool_to_llm',
            LLM_DECIDING: 'llm_deciding', // Deciding whether to stop or continue
            FINAL_ANSWER: 'final_answer',
            COMPLETE: 'complete',
            ERROR: 'error'
        };
        let simulationState = SIM_STATE.IDLE;
        let currentStep = 0;
        const maxSteps = 10; // Max ReAct cycles
        let currentTool = null;
        let tooltipElement, statusElement, labelsContainer;
        let raycaster, mouse;
        const labelUpdateVector = new THREE.Vector3(); // Reusable vector for label calculations
        let memoryBlockGeometry; // Define later after THREE is loaded
        let memoryBlockMaterial; // Define later after THREE is loaded
        let currentTimeoutId = null; // To store pending setTimeout ID for cancellation on reset

        // --- Constants ---
        const SIGNAL_DURATION_PROMPT = 1000; // Faster: 2000 -> 1000
        const SIGNAL_DURATION_TOOL = 750;  // Faster: 1500 -> 750
        const THINKING_TIME = 500; // ms for LLM thinking/deciding/tool processing simulation

        // --- Initialization ---
        function init() {
            console.log("Initializing visualization...");
            tooltipElement = document.getElementById('tooltip');
            statusElement = document.getElementById('status');
            labelsContainer = document.getElementById('labels-container');

            // Define geometries/materials that depend on THREE here
            memoryBlockGeometry = new THREE.BoxGeometry(Sizes.memoryBlockWidth, Sizes.memoryBlockHeight, Sizes.memoryBlockDepth);
            memoryBlockMaterial = new THREE.MeshStandardMaterial({ color: Colors.memory, roughness: 0.8, metalness: 0.1 });

            setupThreeJS();
            setupMatterJS();
            setupSceneContent();
            setupInteraction();
            animate();
            updateStatus('Idle. Press "Start Analysis".');
            console.log("Initialization complete.");
        }

        // --- Setup Functions ---
        function setupThreeJS() {
            console.log("Setting up Three.js...");
            scene = new THREE.Scene();
            scene.background = new THREE.Color(Colors.background);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 0, 250);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(Colors.ambientLight));
            const dirLight = new THREE.DirectionalLight(Colors.directionalLight, 1.5);
            dirLight.position.set(50, 50, 100);
            scene.add(dirLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = false;
            controls.minDistance = 50;
            controls.maxDistance = 800;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('resize', onWindowResize, false);
            console.log("Three.js setup complete.");
        }

        function setupMatterJS() {
            console.log("Setting up Matter.js...");
            if (typeof Matter === 'undefined') {
                 console.error("FATAL: Matter.js global object not found!");
                 alert("Error: Matter.js library failed to load.");
                 return;
            }
            engine = Matter.Engine.create();
            world = engine.world;
            world.gravity.y = 0; // No gravity in this visualization plane
            console.log("Matter.js setup complete.");
        }

        function setupSceneContent() {
            console.log("Setting up scene content...");
            try {
                // --- LLM Core ---
                console.log("Creating LLM Core...");
                const llmPos = { x: 0, y: 0 };
                const llmBody = Matter.Bodies.circle(llmPos.x, llmPos.y, Sizes.llmRadius, { isStatic: true, label: 'LLM Core', restitution: 0.5 });
                const llmMesh = createMesh(new THREE.SphereGeometry(Sizes.llmRadius, 32, 32), Colors.llm, llmPos.x, llmPos.y, 0);
                if (!llmMesh) throw new Error("Failed to create LLM mesh.");
                llmMesh.userData = { info: "Language Model (e.g., GPT-4o-mini)\nProcesses prompts and orchestrates tool use.", body: llmBody };
                objects.llm = { mesh: llmMesh, body: llmBody };
                addObject(llmMesh, llmBody);
                addLabel(llmMesh, "LLM Core", Sizes.llmRadius);

                // --- System Prompt & Sub-Prompts ---
                console.log("Creating System Prompt...");
                const sysPromptPos = { x: -150, y: 80 };
                const sysPromptBody = Matter.Bodies.rectangle(sysPromptPos.x, sysPromptPos.y, Sizes.promptSize * 1.5, Sizes.promptSize * 1.5, { isStatic: true, label: 'System Prompt', restitution: 0.5 });
                const sysPromptMesh = createMesh(new THREE.BoxGeometry(Sizes.promptSize, Sizes.promptSize, Sizes.promptSize), Colors.systemPrompt, sysPromptPos.x, sysPromptPos.y, 0);
                if (!sysPromptMesh) throw new Error("Failed to create System Prompt mesh.");
                if (!PromptData || typeof PromptData !== 'object') throw new Error("PromptData object is missing or invalid.");
                const sysPromptInfo = "System Prompt:\n" + Object.values(PromptData).slice(0, -1).join("\n- ");
                sysPromptMesh.userData = { info: sysPromptInfo, body: sysPromptBody };
                objects.systemPrompt = { mesh: sysPromptMesh, body: sysPromptBody };
                addObject(sysPromptMesh, sysPromptBody);
                addLabel(sysPromptMesh, "System Prompt", Sizes.promptSize);
                addConnection(objects.llm, objects.systemPrompt);

                console.log("Creating Sub-Prompts...");
                const subPromptNames = Object.keys(PromptData).slice(0, -1); // Exclude USER_PROMPT_EXAMPLE
                const angleStepSub = (Math.PI * 2) / subPromptNames.length;
                subPromptNames.forEach((name, i) => {
                    const angle = angleStepSub * i + Math.PI / 4; // Offset start angle slightly
                    const radius = Sizes.promptSize * 2.5; // Radius from System Prompt center
                    const pos = { x: sysPromptPos.x + radius * Math.cos(angle), y: sysPromptPos.y + radius * Math.sin(angle) };
                    const body = Matter.Bodies.rectangle(pos.x, pos.y, Sizes.subPromptSize * 1.5, Sizes.subPromptSize * 1.5, { isStatic: true, label: `Sub-Prompt: ${name}`, restitution: 0.5 });
                    const mesh = createMesh(new THREE.BoxGeometry(Sizes.subPromptSize, Sizes.subPromptSize, Sizes.subPromptSize), Colors.subPrompt, pos.x, pos.y, 0);
                    if (!mesh) throw new Error(`Failed to create Sub-Prompt mesh for ${name}.`);
                    if (!PromptData[name]) console.warn(`PromptData missing key: ${name}`);
                    mesh.userData = { info: `Sub-Prompt: ${name}\n${PromptData[name] || 'Info missing'}`, body: body };
                    const subPromptObj = { mesh: mesh, body: body, name: name };
                    objects.subPrompts.push(subPromptObj);
                    addObject(mesh, body);
                    // *** ADD LABEL FOR SUB-PROMPT ***
                    addLabel(mesh, name.replace(/_/g, ' '), Sizes.subPromptSize); // Use key as label, replace underscores
                    addConnection(objects.systemPrompt, subPromptObj, 0.1); // Connect to System Prompt
                });

                // --- User Prompt ---
                console.log("Creating User Prompt...");
                const userPromptPos = { x: -150, y: -80 };
                const userPromptBody = Matter.Bodies.rectangle(userPromptPos.x, userPromptPos.y, Sizes.promptSize * 1.5, Sizes.promptSize * 1.5, { isStatic: false, label: 'User Prompt', restitution: 0.5, frictionAir: 0.05 });
                const userPromptMesh = createMesh(new THREE.BoxGeometry(Sizes.promptSize, Sizes.promptSize, Sizes.promptSize), Colors.userPrompt, userPromptPos.x, userPromptPos.y, 0);
                if (!userPromptMesh) throw new Error("Failed to create User Prompt mesh object.");
                console.log("User Prompt mesh created successfully:", userPromptMesh);
                if (typeof PromptData.USER_PROMPT_EXAMPLE === 'undefined') console.warn("PromptData.USER_PROMPT_EXAMPLE is undefined!");
                userPromptMesh.userData = { info: `User Prompt (Example):\n${PromptData.USER_PROMPT_EXAMPLE || 'Example missing'}`, body: userPromptBody };
                console.log("Set userData for User Prompt.");
                objects.userPrompt = { mesh: userPromptMesh, body: userPromptBody };
                addObject(userPromptMesh, userPromptBody);
                addLabel(userPromptMesh, "User Prompt", Sizes.promptSize);
                console.log("User Prompt added to scene.");

                // --- Tools (Clustered on the Right) ---
                console.log("Creating Tools...");
                if (!ToolData || typeof ToolData !== 'object') throw new Error("ToolData object is missing or invalid.");
                const toolNames = Object.keys(ToolData);
                const numTools = toolNames.length;
                const toolClusterRadius = 150;
                const clusterStartAngle = -Math.PI / 2.5; // Start angle for cluster (right side)
                const clusterEndAngle = Math.PI / 2.5;   // End angle for cluster
                const totalClusterAngle = clusterEndAngle - clusterStartAngle;
                const toolAngleStep = numTools > 1 ? totalClusterAngle / (numTools - 1) : 0; // Avoid division by zero if only 1 tool

                toolNames.forEach((name, i) => {
                    // Calculate angle for this tool within the cluster
                    const angle = clusterStartAngle + (toolAngleStep * i);
                    const pos = {
                        x: llmPos.x + toolClusterRadius * Math.cos(angle),
                        y: llmPos.y + toolClusterRadius * Math.sin(angle)
                    };
                    const body = Matter.Bodies.rectangle(pos.x, pos.y, Sizes.toolSize * 1.5, Sizes.toolSize * 1.5, { isStatic: true, label: `Tool: ${name}`, restitution: 0.5 });
                    let geometry; // Keep varied geometry
                    if (i % 3 === 0) geometry = new THREE.BoxGeometry(Sizes.toolSize, Sizes.toolSize, Sizes.toolSize);
                    else if (i % 3 === 1) geometry = new THREE.CylinderGeometry(Sizes.toolSize * 0.7, Sizes.toolSize * 0.7, Sizes.toolSize, 16);
                    else geometry = new THREE.ConeGeometry(Sizes.toolSize * 0.8, Sizes.toolSize * 1.2, 16);

                    const mesh = createMesh(geometry, Colors.tool, pos.x, pos.y, 0);
                    if (!mesh) throw new Error(`Failed to create Tool mesh for ${name}.`);
                    if (!ToolData[name]) console.warn(`ToolData missing key: ${name}`);
                    mesh.userData = { info: `Tool: ${name}\n${ToolData[name] || 'Info missing'}`, body: body };
                    const toolObj = { mesh: mesh, body: body, name: name };
                    objects.tools[name] = toolObj;
                    addObject(mesh, body);
                    addLabel(mesh, `Tool: ${name}`, Sizes.toolSize);
                    addConnection(objects.llm, toolObj);
                });
                console.log("Tools created.");

            } catch (error) {
                console.error("Error during setupSceneContent:", error);
                alert(`An error occurred during scene setup: ${error.message}\nCheck the console for details.`);
            }
            console.log("Scene content setup complete.");
        }

        // --- Helper Functions ---
        function createMesh(geometry, color, x, y, z) {
            try {
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    roughness: 0.5,
                    metalness: 0.2,
                    transparent: true,
                    opacity: 0.9
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            } catch (error) {
                console.error("Error in createMesh:", error);
                return undefined; // Explicitly return undefined on error
            }
        }

        function addObject(mesh, body) {
            if (!mesh || !body) {
                console.error("Attempted to add invalid mesh or body:", mesh, body);
                return;
            }
            scene.add(mesh);
            Matter.World.add(world, body);
            matterBodies.push(body);
            threeMeshes.push(mesh);
        }

        function addLabel(mesh, text, objectSize) {
             if (!mesh) {
                console.error("Attempted to add label to invalid mesh for text:", text);
                return;
            }
            const labelDiv = document.createElement('div');
            labelDiv.className = 'object-label';
            labelDiv.textContent = text;
            labelsContainer.appendChild(labelDiv);
            labeledObjects.push({ mesh, labelElement: labelDiv, text, size: objectSize });
        }

        function updateLabels() {
            labeledObjects.forEach(item => {
                if (!item || !item.mesh || !item.labelElement || !item.mesh.position) return; // Add safety checks

                // Calculate offset position slightly above the object's center
                const offsetDistance = item.size * Sizes.labelOffset;
                labelUpdateVector.set(item.mesh.position.x, item.mesh.position.y + offsetDistance, item.mesh.position.z);

                // Project 3D position to 2D screen space
                labelUpdateVector.project(camera);

                // Check if the label is behind the camera (z > 1 in normalized device coords)
                const isBehindCamera = labelUpdateVector.z > 1;

                // Convert normalized device coordinates (-1 to +1) to CSS pixels
                const x = (labelUpdateVector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
                const y = (-labelUpdateVector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;

                // Update the CSS position
                item.labelElement.style.left = `${x}px`;
                item.labelElement.style.top = `${y}px`;

                // Hide label if it's behind the camera or too far outside the view boundaries
                 if (isBehindCamera || x < -100 || x > renderer.domElement.clientWidth + 100 || y < -100 || y > renderer.domElement.clientHeight + 100) {
                     item.labelElement.style.display = 'none';
                 } else {
                     item.labelElement.style.display = 'block';
                 }
            });
        }

        function addConnection(objA, objB, stiffness = 0.01, length = null) {
            if (!objA || !objB || !objA.body || !objB.body || !objA.mesh || !objB.mesh) {
                 console.error("Attempted to add connection between invalid objects:", objA, objB);
                 return;
            }
            const bodyA = objA.body;
            const bodyB = objB.body;
            if (!length) {
                 length = Math.hypot(bodyA.position.x - bodyB.position.x, bodyA.position.y - bodyB.position.y);
            }
            const constraint = Matter.Constraint.create({ bodyA, bodyB, stiffness, length, render: { visible: false } });
            Matter.World.add(world, constraint);
            constraints.push(constraint);

            const points = [ new THREE.Vector3(), new THREE.Vector3() ]; // Updated later
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: Colors.connection, transparent: true, opacity: 0.5 });
            const line = new THREE.Line(geometry, material);
            line.userData.constraint = constraint; // Link line to constraint
            scene.add(line);
            objects.connections.push(line);
        }

        function setupInteraction() {
            // Only Start and Reset buttons now
            document.getElementById('startButton').addEventListener('click', startAnalysis);
            document.getElementById('resetButton').addEventListener('click', resetSimulation);
        }

        // --- Memory Visualization ---
        function addMemoryItem() {
            if (!objects.llm || !objects.llm.body) {
                 console.error("Cannot add memory item: LLM object not ready.");
                 return;
            }
            const llmPos = objects.llm.body.position;
            const stackHeight = memoryItems.length * (Sizes.memoryBlockHeight + Sizes.memoryStackOffset);

            // Ensure geometry and material are defined
             if (!memoryBlockGeometry || !memoryBlockMaterial) {
                 console.error("Memory block geometry or material not initialized!");
                 return;
             }

            const memMesh = new THREE.Mesh(memoryBlockGeometry, memoryBlockMaterial);
            // Position to the right of LLM, stacking upwards from near the bottom
            memMesh.position.set(
                llmPos.x + Sizes.memoryStackXOffset,
                llmPos.y - Sizes.llmRadius + Sizes.memoryBlockHeight / 2 + stackHeight,
                0
            );
            memMesh.castShadow = true;
            memMesh.receiveShadow = true;

            scene.add(memMesh);
            memoryItems.push(memMesh);

            // Optional: Add subtle animation on creation
            memMesh.scale.set(0.1, 0.1, 0.1);
            const targetScale = 1.0;
            const growDuration = 300;
            const startTime = Date.now();
            function animateGrowth() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / growDuration, 1);
                const scale = 0.1 + progress * (targetScale - 0.1);
                // Check if mesh still exists before scaling (it might have been reset)
                if (memoryItems.includes(memMesh)) {
                     memMesh.scale.set(scale, scale, scale);
                     if (progress < 1) {
                         requestAnimationFrame(animateGrowth);
                     }
                }
            }
            animateGrowth();
        }

        // --- Simulation Control ---

        function startAnalysis() {
            if (simulationState !== SIM_STATE.IDLE) return; // Prevent starting multiple times
            console.log("Starting analysis simulation...");
            resetSimulationVisuals(); // Clear previous state
            simulationState = SIM_STATE.PROMPTS_TO_LLM;
            currentStep = 0;
            document.getElementById('startButton').disabled = true; // Disable start until reset

            processCurrentState(); // Start the automated flow
        }

        // Central function to handle state transitions and actions
        function processCurrentState() {
            // Clear any previous timeout if it exists
            if (currentTimeoutId) {
                clearTimeout(currentTimeoutId);
                currentTimeoutId = null;
            }

            // Ensure core objects exist if needed by the current state
             if (simulationState !== SIM_STATE.IDLE && simulationState !== SIM_STATE.COMPLETE && simulationState !== SIM_STATE.ERROR) {
                 if (!objects.llm || !objects.llm.mesh || !objects.llm.body) {
                     console.error(`Cannot process state ${simulationState}: LLM object missing.`);
                     return changeState(SIM_STATE.ERROR, "Error: LLM object missing.");
                 }
             }

            console.log(`Processing State: ${simulationState}, Step: ${currentStep}`);

            switch (simulationState) {
                case SIM_STATE.PROMPTS_TO_LLM:
                    updateStatus('System & User Prompts -> LLM: Sending Initial Request');
                    addMemoryItem(); // System Prompt memory
                    addMemoryItem(); // User Prompt memory

                    if (!objects.userPrompt || !objects.userPrompt.body || !objects.systemPrompt || !objects.systemPrompt.body) {
                         console.error("Cannot start analysis: Core prompt objects not ready.");
                         return changeState(SIM_STATE.ERROR, "Error: Prompt objects missing.");
                    }

                    // Animate user prompt movement
                    const userPromptBody = objects.userPrompt.body;
                    const llmBody = objects.llm.body;
                    Matter.Body.setStatic(userPromptBody, false);
                    const forceMagnitude = 0.005 * userPromptBody.mass;
                    const angle = Math.atan2(llmBody.position.y - userPromptBody.position.y, llmBody.position.x - userPromptBody.position.x);
                    Matter.Body.applyForce(userPromptBody, userPromptBody.position, { x: forceMagnitude * Math.cos(angle), y: forceMagnitude * Math.sin(angle) });

                    // Send signals from both prompts
                    createSignal(objects.userPrompt, objects.llm, SIGNAL_DURATION_PROMPT, () => {
                        // Only transition state once both signals conceptually arrive (use user prompt arrival)
                        if (simulationState === SIM_STATE.PROMPTS_TO_LLM) {
                            changeState(SIM_STATE.LLM_THINKING); // Move to thinking state
                        }
                    });
                    createSignal(objects.systemPrompt, objects.llm, SIGNAL_DURATION_PROMPT, null); // No callback needed for this one
                    break;

                case SIM_STATE.LLM_THINKING: // Deciding which tool to call
                    updateStatus('LLM: Processing / Selecting Tool (Thought)');
                    flashObject(objects.llm.mesh, 2, 300); // Flash LLM while thinking

                    // Simulate thinking time
                    currentTimeoutId = setTimeout(() => {
                        const toolNames = Object.keys(objects.tools);
                        if (toolNames.length === 0) {
                            console.warn("No tools available.");
                            changeState(SIM_STATE.LLM_DECIDING); // Go straight to deciding if no tools
                        } else {
                            currentTool = toolNames[Math.floor(Math.random() * toolNames.length)];
                            if (!objects.tools[currentTool] || !objects.tools[currentTool].mesh) {
                                console.error(`Selected tool '${currentTool}' is invalid.`);
                                changeState(SIM_STATE.ERROR, `Error: Invalid tool selected: ${currentTool}`);
                            } else {
                                changeState(SIM_STATE.LLM_TO_TOOL); // Ready to call tool
                            }
                        }
                    }, THINKING_TIME);
                    break;

                case SIM_STATE.LLM_TO_TOOL:
                    updateStatus(`LLM -> Tool: Requesting '${currentTool}' (Action)`);
                    flashObject(objects.llm.mesh); // Flash LLM as it sends request
                    createSignal(objects.llm, objects.tools[currentTool], SIGNAL_DURATION_TOOL, () => {
                        if (simulationState === SIM_STATE.LLM_TO_TOOL) {
                            addMemoryItem(); // Add memory for the LLM's action message
                            changeState(SIM_STATE.TOOL_PROCESSING);
                        }
                    });
                    break;

                case SIM_STATE.TOOL_PROCESSING:
                    updateStatus(`Tool ('${currentTool}'): Executing...`);
                    flashObject(objects.tools[currentTool].mesh, 3, 200); // Flash tool while processing

                    // Simulate tool execution time
                    currentTimeoutId = setTimeout(() => {
                        if (!currentTool || !objects.tools[currentTool]) {
                             console.error("Cannot send tool result: Current tool is invalid.");
                             changeState(SIM_STATE.LLM_THINKING); // Try to recover by thinking again
                        } else {
                             changeState(SIM_STATE.TOOL_TO_LLM); // Tool finished, send result
                        }
                    }, THINKING_TIME); // Use same delay for simplicity
                    break;

                case SIM_STATE.TOOL_TO_LLM:
                    updateStatus(`Tool ('${currentTool}') -> LLM: Sending Result (Observation)`);
                    flashObject(objects.tools[currentTool].mesh); // Flash tool as it sends result
                    createSignal(objects.tools[currentTool], objects.llm, SIGNAL_DURATION_TOOL, () => {
                        if (simulationState === SIM_STATE.TOOL_TO_LLM) {
                            addMemoryItem(); // Add memory for the Tool's observation message
                            currentStep++; // Increment ReAct step count *after* a full cycle (Action+Observation)
                            changeState(SIM_STATE.LLM_DECIDING); // LLM needs to decide what's next
                        }
                    });
                    currentTool = null; // Clear current tool after sending result
                    break;

                case SIM_STATE.LLM_DECIDING: // New state for decision visualization
                    updateStatus('LLM: Deciding next action...');
                    flashObject(objects.llm.mesh, 2, 250, 0xffff00); // Flash yellow briefly for decision

                    currentTimeoutId = setTimeout(() => {
                        // Decision logic
                        const shouldFinish = (currentStep >= maxSteps || Math.random() > 0.3); // Finish if max steps or random chance

                        if (shouldFinish) {
                            updateStatus('LLM: Decision -> Generate Final Answer');
                            flashObject(objects.llm.mesh, 1, 400, Colors.finalAnswer); // Flash purple
                            changeState(SIM_STATE.FINAL_ANSWER);
                        } else {
                            updateStatus('LLM: Decision -> Call Another Tool');
                            flashObject(objects.llm.mesh, 1, 300); // Normal flash
                            changeState(SIM_STATE.LLM_THINKING); // Go back to select a tool
                        }
                    }, THINKING_TIME); // Simulate decision time
                    break;

                case SIM_STATE.FINAL_ANSWER:
                    updateStatus('LLM: Generating Final Answer...');
                    flashObject(objects.llm.mesh, 5, 200); // Flash more intensely
                    createFinalAnswer(); // Creates mesh and label
                    addMemoryItem(); // Add memory for the final answer message

                    // Add a short delay before setting state to COMPLETE
                    currentTimeoutId = setTimeout(() => {
                         changeState(SIM_STATE.COMPLETE, "Analysis Complete.");
                    }, 1500); // Wait for final answer animation a bit
                    break;

                case SIM_STATE.COMPLETE:
                case SIM_STATE.ERROR:
                case SIM_STATE.IDLE:
                    // No automatic processing needed for these states
                    // Re-enable start button if stopped/errored/idle
                    const startButton = document.getElementById('startButton');
                    if (startButton) startButton.disabled = false;
                    break;

                default:
                    console.error(`Unknown simulation state: ${simulationState}`);
                    changeState(SIM_STATE.ERROR, `Error: Unknown state ${simulationState}`);
            }
        }

        // Helper to change state and trigger processing
        function changeState(newState, statusMessage = null) {
            console.log(`Transitioning State: ${simulationState} -> ${newState}`);
            simulationState = newState;
            if (statusMessage) {
                updateStatus(statusMessage);
            }
            // If the new state requires automatic processing, call the processor
            if (newState !== SIM_STATE.IDLE && newState !== SIM_STATE.COMPLETE && newState !== SIM_STATE.ERROR) {
                 // Use setTimeout to allow current execution stack to clear before processing next state
                 // This prevents potential deep recursion issues if states change very rapidly
                 setTimeout(processCurrentState, 0);
            } else if (newState === SIM_STATE.COMPLETE || newState === SIM_STATE.ERROR || newState === SIM_STATE.IDLE) {
                 // Ensure start button is enabled when finished, errored or idle
                 const startButton = document.getElementById('startButton');
                 if (startButton) startButton.disabled = false;
            }
        }


        function endSimulation(message) { // Now just updates status and enables start button
            updateStatus(message);
            // Let changeState handle setting the state and enabling button
            // simulationState = SIM_STATE.COMPLETE; // Or ERROR depending on message?
            // const startButton = document.getElementById('startButton');
            // if (startButton) startButton.disabled = false;
        }

        function resetSimulation() {
            console.log("Resetting simulation...");
            // Clear pending timeout FIRST
            if (currentTimeoutId) {
                clearTimeout(currentTimeoutId);
                currentTimeoutId = null;
            }
            resetSimulationVisuals(); // Clears signals, final answer, memory, sub-prompt labels

            // Reset User Prompt physics state if it exists
            if (objects.userPrompt && objects.userPrompt.body) {
                const userPromptBody = objects.userPrompt.body;
                Matter.Body.setStatic(userPromptBody, true); // Make static temporarily
                Matter.Body.setPosition(userPromptBody, { x: -150, y: -80 });
                Matter.Body.setVelocity(userPromptBody, { x: 0, y: 0 });
                Matter.Body.setAngularVelocity(userPromptBody, 0);
                Matter.Body.setStatic(userPromptBody, false); // Make dynamic again
            } else {
                 console.warn("Could not reset User Prompt position - object missing.");
            }

            changeState(SIM_STATE.IDLE, "Simulation Reset."); // Set state to IDLE
            currentStep = 0;
            currentTool = null;
            // Start button is re-enabled by changeState logic for IDLE
        }

        function resetSimulationVisuals() {
            // Clear pending timeout
             if (currentTimeoutId) {
                 clearTimeout(currentTimeoutId);
                 currentTimeoutId = null;
             }
            // Remove signals
            objects.signals.forEach(signal => { if (signal.mesh) scene.remove(signal.mesh); });
            objects.signals = [];

            // Remove final answer mesh and its label info
            if (objects.finalAnswerObj) {
                if (objects.finalAnswerObj.mesh) scene.remove(objects.finalAnswerObj.mesh);
                // Remove label info from array
                labeledObjects = labeledObjects.filter(item => !item || item.mesh !== objects.finalAnswerObj.mesh);
                // Remove label element from DOM (find it first)
                const finalAnswerLabel = Array.from(labelsContainer.children).find(el => el.textContent === "Final Answer");
                if (finalAnswerLabel) labelsContainer.removeChild(finalAnswerLabel);

                objects.finalAnswerObj = null;
            }

            // Remove memory items
            memoryItems.forEach(item => scene.remove(item));
            memoryItems = [];

            // Reset object appearances (color/scale)
            [objects.llm, objects.systemPrompt, objects.userPrompt, ...objects.subPrompts, ...Object.values(objects.tools)].forEach(obj => {
                if (obj && obj.mesh && obj.mesh.material) {
                    obj.mesh.material.emissive.setHex(0x000000);
                     obj.mesh.scale.set(1, 1, 1);
                }
            });

            // Remove labels associated with sub-prompts
            const subPromptMeshes = objects.subPrompts.map(sp => sp.mesh);
            labeledObjects = labeledObjects.filter(item => {
                if (item && item.labelElement && subPromptMeshes.includes(item.mesh)) {
                     // Check if parentNode exists before removing
                     if (item.labelElement.parentNode === labelsContainer) {
                         labelsContainer.removeChild(item.labelElement);
                     }
                     return false; // Remove from array
                }
                return true; // Keep other labels (LLM, System/User Prompt, Tools)
            });
        }


        function createSignal(fromObj, toObj, duration, onComplete) {
             if (!fromObj || !toObj || !fromObj.body || !toObj.body) {
                 console.error("Cannot create signal: Invalid 'from' or 'to' object.", fromObj, toObj);
                 return;
             }
            const startPos = new THREE.Vector3(fromObj.body.position.x, fromObj.body.position.y, 5); // Slightly above plane
            const endPos = new THREE.Vector3(toObj.body.position.x, toObj.body.position.y, 5);

            const signalGeom = new THREE.SphereGeometry(Sizes.signalRadius, 8, 8);
            const signalMat = new THREE.MeshBasicMaterial({ color: Colors.signal });
            const signalMesh = new THREE.Mesh(signalGeom, signalMat);
            signalMesh.position.copy(startPos);
            scene.add(signalMesh);

            const signal = { mesh: signalMesh, startTime: Date.now(), duration, startPos, endPos, onComplete };
            objects.signals.push(signal);
        }

         function createFinalAnswer() {
            if (objects.finalAnswerObj) return; // Already exists
            if (!objects.llm || !objects.llm.body) {
                 console.error("Cannot create final answer: LLM object not ready.");
                 return;
            }

            const llmPos = objects.llm.body.position;
            const answerPos = { x: llmPos.x + Sizes.llmRadius + 50, y: llmPos.y }; // Position it near LLM

            const geometry = new THREE.TorusKnotGeometry(15, 5, 100, 16);
            const material = new THREE.MeshStandardMaterial({ color: Colors.finalAnswer, roughness: 0.3, metalness: 0.4, emissive: Colors.finalAnswer, emissiveIntensity: 0.5 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(answerPos.x, answerPos.y, 0);
            mesh.scale.set(0.1, 0.1, 0.1); // Start small
            scene.add(mesh);

            objects.finalAnswerObj = { mesh: mesh, startTime: Date.now() }; // Label added below
            addLabel(mesh, "Final Answer", 20); // Add label AFTER object exists

            // Animate growth
            const growDuration = 1000; // Keep growth animation duration reasonable
            const targetScale = 1.0;
            function animateGrowth() {
                // Check if object still exists (might have been reset)
                if (!objects.finalAnswerObj || !objects.finalAnswerObj.mesh) return;
                const elapsed = Date.now() - objects.finalAnswerObj.startTime;
                const progress = Math.min(elapsed / growDuration, 1);
                const scale = 0.1 + progress * (targetScale - 0.1);
                objects.finalAnswerObj.mesh.scale.set(scale, scale, scale);
                objects.finalAnswerObj.mesh.rotation.y += 0.02;
                 objects.finalAnswerObj.mesh.rotation.x += 0.01;
                if (progress < 1) {
                    requestAnimationFrame(animateGrowth);
                }
            }
            animateGrowth();
        }

        // Modified flashObject to accept an optional flash color
        function flashObject(mesh, times = 1, duration = 200, flashColorHex = 0xffffff) {
            if (!mesh || !mesh.material) {
                 console.warn("Attempted to flash invalid mesh:", mesh);
                 return;
            }
            const originalEmissive = mesh.material.emissive.getHex();
            const originalIntensity = mesh.material.emissiveIntensity; // Store original intensity
            let count = 0;

            function doFlash() {
                // Check again inside timeout in case mesh was removed
                if (!mesh || !mesh.material) return;
                if (count >= times * 2) {
                    mesh.material.emissive.setHex(originalEmissive);
                    mesh.material.emissiveIntensity = originalIntensity; // Restore original intensity
                    return;
                }
                const isFlashOn = count % 2 === 0;
                mesh.material.emissive.setHex(isFlashOn ? flashColorHex : originalEmissive);
                mesh.material.emissiveIntensity = isFlashOn ? 1.0 : originalIntensity; // Use 1.0 for flash, restore original otherwise
                count++;
                setTimeout(doFlash, duration / 2);
            }
            doFlash();
        }

        function updateStatus(text) {
            if (statusElement) {
                statusElement.textContent = text;
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();

            // Update Physics Engine if it exists
            if (engine) {
                 Matter.Engine.update(engine, 1000 / 60); // Update at 60Hz
            }

            // Sync Three.js meshes with Matter.js bodies
            for (let i = 0; i < matterBodies.length; i++) {
                const body = matterBodies[i];
                const mesh = threeMeshes[i];
                // Check if both exist before accessing properties
                if (mesh && body && mesh.position) {
                    mesh.position.set(body.position.x, body.position.y, mesh.position.z); // Keep Z position
                    mesh.rotation.z = body.angle; // Rotate around Z axis based on Matter's angle
                }
            }

             // Update Connection Lines
            objects.connections.forEach(line => {
                if (!line || !line.userData || !line.userData.constraint) return;
                const constraint = line.userData.constraint;
                if (!constraint.bodyA || !constraint.bodyB) return;
                const posA = constraint.bodyA.position;
                const posB = constraint.bodyB.position;
                if (line.geometry && line.geometry.attributes && line.geometry.attributes.position) {
                    const positions = line.geometry.attributes.position.array;
                    positions[0] = posA.x; positions[1] = posA.y; positions[2] = 0;
                    positions[3] = posB.x; positions[4] = posB.y; positions[5] = 0;
                    line.geometry.attributes.position.needsUpdate = true;
                }
            });

            // Animate Signals
            const signalsToRemove = [];
            objects.signals.forEach((signal, index) => {
                 if (!signal || !signal.mesh) return;
                const elapsed = now - signal.startTime;
                const progress = Math.min(elapsed / signal.duration, 1);
                signal.mesh.position.lerpVectors(signal.startPos, signal.endPos, progress);

                if (progress >= 1) {
                    scene.remove(signal.mesh);
                    signalsToRemove.push(index);
                    if (signal.onComplete) {
                        try { signal.onComplete(); } catch(e) { console.error("Error in signal onComplete callback:", e); }
                    }
                }
            });
            // Remove completed signals (iterate backwards)
            for (let i = signalsToRemove.length - 1; i >= 0; i--) {
                objects.signals.splice(signalsToRemove[i], 1);
            }

             // Animate Final Answer (rotation mainly, growth handled separately)
            if (objects.finalAnswerObj && objects.finalAnswerObj.mesh) {
                 const elapsed = Date.now() - objects.finalAnswerObj.startTime;
                 if (elapsed > 1000) { // Only rotate after initial growth
                    objects.finalAnswerObj.mesh.rotation.y += 0.01;
                    objects.finalAnswerObj.mesh.rotation.x += 0.005;
                 }
            }

            // Update Controls and Labels if they exist
            if (controls) controls.update();
            if (camera && renderer) updateLabels(); // Update 2D labels

            // Render Scene if renderer and scene exist
            if (renderer && scene && camera) {
                 renderer.render(scene, camera);
            }
        }

        // --- Event Handlers ---
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        function onMouseMove(event) {
             if (!raycaster || !camera || !mouse || !tooltipElement) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const meshesToIntersect = Array.isArray(threeMeshes) ? threeMeshes : [];
            const intersects = raycaster.intersectObjects(meshesToIntersect);

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                // Check if userData and info exist before accessing
                if (intersectedMesh.userData && typeof intersectedMesh.userData.info !== 'undefined') {
                    tooltipElement.style.display = 'block';
                    tooltipElement.style.left = `${event.clientX + 15}px`;
                    tooltipElement.style.top = `${event.clientY + 15}px`;
                    tooltipElement.textContent = intersectedMesh.userData.info;
                } else {
                    tooltipElement.style.display = 'none';
                }
            } else {
                tooltipElement.style.display = 'none';
            }
        }

        // --- Start ---
        // Wrap init in a DOMContentLoaded listener for safety
        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>